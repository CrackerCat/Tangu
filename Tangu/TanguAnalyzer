#pragma once
#ifndef _TANGU_ANALYZER
#define _TANGU_ANALYZER

#include "_NetManager"
#include "_PacketField"

typedef char* HTTPHeader;

enum class PktBegin
{
	LAYER_DATALINK,
	LAYER_NETWORK,
	LAYER_TRANSPORT,
};

__interface PacketAnalyzer
{
	virtual const string& PktParser(const byte*, PktBegin) = 0;
};

class PacketInfo : public PacketAnalyzer
{
protected:
	string						_DumpContent;
	const string				_DumpFiltered;
	char						_Format[FORMAT_MESSAGE_ALLOCATE_BUFFER];
	unsigned __int64		_No;

	pcap_t*					_Interface;
	struct pcap_pkthdr*	_PacketHeader;
	const byte*				_PacketData;

public:
	EthernetHeader			_MyEthernet;
	ARPArchitect				_ARPFrame;

	IPHeader					_MyIP;
	ICMPArchitecture		_ICMPPacket;

	TCPHeader				_MyTCP;

	HTTPHeader				_HTTP;

public:
	PacketInfo();

public:
	const string& DumpData(struct pcap_pkthdr*, const byte*, const unsigned int Length = 16);

	template <typename _Filter = Common>
	__int32 DumpInterface(_Filter* PacketCapturer, std::ostream* Stream)
	{
		PacketAnalyzer*			MyPcapAnalyzer(PacketCapturer);
		__int32					Ret;

		while ((Ret = pcap_next_ex(_Interface, &_PacketHeader, &_PacketData)) >= 0)
		{
			if (Ret == 0)
			{
				continue;
			}
			
			const string& MyHeader(MyPcapAnalyzer->PktParser(_PacketHeader, _PacketData));
			if (MyHeader.length() > 0)
			{
				if (Stream != nullptr)
				{
					system("CLS");
					Stream << MyHeader << endl;
					Stream << PacketCapturer->DumpData(_PacketHeader, _PacketData) << endl;
				}
			}
		}

		return Ret;
	}
};

class Common : public PacketInfo
{
public:
	Common(pcap_t*);

public:
	virtual const string& PktParser(const byte*, PktBegin);
};

class ARPAnalyzer : public PacketInfo
{
public:
	ARPAnalyzer(pcap_t*);

public:
	virtual const string& PktParser(const byte*, PktBegin);
};

class PcapTool
{
protected:
	pcap_t**				_Interface;
	pcap_pkthdr*		_PacketHeader;
	const byte*			_PacketData;

	PacketAnalyzer*		_PcapAnalyzer;		/* virtual class : DumpHeader */
	int32_t				_Ret;
	bool					_CollectSuccess;

protected:
	PcapTool::PcapTool(void);
};

class NetInfo : protected PcapTool
{
public:
	ARP	_ARPFrame;

public:
	NetInfo::NetInfo(pcap_t**);

protected:
	void NetInfo::GenerateARP(ARPArchitect::Opcode);
	EthernetHeader NetInfo::GetMACAddress(Net::IPInfo&, double);
	Net::MACInfo NetInfo::CollectNetworkInfo(Net::IPInfo&, double);

public:
	bool NetInfo::IsARPValid(void);
};

#endif /* _ANALYZER */